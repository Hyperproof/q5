import { Command, IExecuteInput, ArgType } from '@5qtrs/cli';
import { Text } from '@5qtrs/text';
import { ProfileService, ExecuteService, AgentService } from '../services';

// ------------------
// Internal Constants
// ------------------

const command = {
  name: 'CLI Initialize',
  cmd: 'init',
  summary: 'Initialize the CLI',
  description:
    'Initializes use of the CLI using an init token generated by an account admin or a hosted settings object.',
  arguments: [
    {
      name: 'token',
      description:
        'The init token generated by an account admin, a URL to Fusebit settings object, or a Github repository name with the Fusebit settings file',
    },
  ],
  options: [
    {
      name: 'profile',
      aliases: ['p'],
      description: 'The name of the profile to create with the initalization of the CLI',
    },
    {
      name: 'subscription',
      aliases: ['s'],
      description: 'Set the subscription command option of the profile to the given subscription',
    },
    {
      name: 'quiet',
      aliases: ['q'],
      description: 'If set to true, does not prompt for confirmation',
      type: ArgType.boolean,
      default: 'false',
    },
    {
      name: 'output',
      aliases: ['o'],
      description: "The format to display the output: 'pretty', 'json'",
      default: 'pretty',
    },
  ],
};

// ----------------
// Exported Classes
// ----------------

export class InitCommand extends Command {
  private constructor() {
    super(command);
  }

  public static async create() {
    return new InitCommand();
  }

  protected async onExecute(input: IExecuteInput): Promise<number> {
    const token = input.arguments[0] as string;
    let profileName = input.options.profile as string;
    const quiet = input.options.quiet as boolean;
    const subscription = input.options.subscription as string;

    const profileService = await ProfileService.create(input);
    const executeService = await ExecuteService.create(input);
    let agentService = await AgentService.create(input);

    await executeService.newLine();

    if (token.match(/^https:\/\//i)) {
      await profileService.execute(async () => initFromUrl(token, token));
    } else {
      const [path, sourceProfile] = token.split('#');
      const [organization, repository, file, rest] = path.split('/');
      if (organization && repository && !rest) {
        await profileService.execute(async () =>
          initFromUrl(
            `https://raw.githubusercontent.com/${organization}/${repository}/master/${file || 'profiles.json'}${
              sourceProfile ? '#' + sourceProfile : ''
            }`,
            token
          )
        );
      } else {
        await initFromToken();
      }
    }

    return 0;

    async function initFromUrl(url: string, srcUrl: string): Promise<void> {
      const [serverUrl, sourceProfile] = url.split('#');
      const settingsResponse = await executeService.executeSimpleRequest(
        {
          header: 'Settings',
          message: Text.create('Obtaining Fusebit profiles from ', Text.bold(serverUrl), '...'),
          errorHeader: 'Settings Error',
          errorMessage: Text.create('Unable to obtain Fusebit settings'),
        },
        {
          method: 'GET',
          url: serverUrl,
        }
      );
      if (settingsResponse.status !== 200) {
        throw new Error(`Error obtaining Fusebit settings. HTTP status: ${settingsResponse.status}.`);
      }
      let settings: any = settingsResponse.data;
      if (typeof settings !== 'object') {
        try {
          settings = JSON.parse(settings);
        } catch (e) {
          throw new Error(`Error obtaining Fusebit settings: data is not a JSON object.`);
        }
      }
      if (!Array.isArray(settings.profiles) || settings.profiles.length === 0) {
        throw new Error(`Invalid Fusebit settings: data does not specify any profile information.`);
      }
      let profile: any;
      if (sourceProfile) {
        for (const p of settings.profiles) {
          if (sourceProfile === p.id) {
            profile = p;
            break;
          }
        }
      }
      if (!profile) {
        if (settings.profiles.length > 1) {
          throw new Error(
            `Fusebit settings contain more than one profile. Select a profile to use by specifying it as a hash value, i.e. '${token}#{profile-name}'. Available profiles are: ${settings.profiles
              .map((p: any) => p.id)
              .join(', ')}.`
          );
        }
        profile = settings.profiles[0];
      }
      if (!profileName) {
        profileName = await profileService.getProfileNameFromBaseUrl(profile.baseUrl);
      }
      if (!quiet) {
        const targetProfile = await profileService.getProfile(profileName);
        if (targetProfile) {
          await profileService.confirmCreateProfile(profileName, targetProfile);
        }
      }

      const newCliProfile: any = {
        baseUrl: profile.baseUrl,
        account: profile.account,
        issuer: profile.oauth && profile.oauth.deviceAuthorizationUrl,
        tokenUrl: profile.oauth && profile.oauth.tokenUrl,
        clientId: profile.oauth && profile.oauth.deviceClientId,
        subscription: subscription === '' ? undefined : subscription || profile.subscription,
      };
      const nameMapping: any = {
        baseUrl: 'baseUrl',
        account: 'account',
        issuer: 'oauth.deviceAuthorizationUrl',
        tokenUrl: 'oauth.tokenUrl',
        clientId: 'oauth.deviceClientId',
      };

      for (const p of Object.keys(newCliProfile)) {
        if (p !== 'subscription' && typeof newCliProfile[p] !== 'string') {
          throw new Error(
            `Invalid Fusebit settings: the '${
              nameMapping[p]
            }' parameter of the '${profileName}' profile must be a string.`
          );
        }
      }

      const addedProfile = await profileService.createProfile(profileName, newCliProfile);

      const defaultProfileName = await profileService.getDefaultProfileName();
      if (!defaultProfileName) {
        await profileService.setDefaultProfileName(profileName);
      }

      const agent = await profileService.getAgent(profileName);
      const agentDetails = await agentService.getAgentDetails(agent, true);
      await profileService.displayProfile(addedProfile, agentDetails);
    }

    async function initFromToken(): Promise<void> {
      const decodedToken = await agentService.decodeInitToken(token);
      const { accountId, subscriptionId, boundaryId, functionId, agentId, baseUrl, issuerId, subject } = decodedToken;

      if (!profileName) {
        profileName = await profileService.getProfileNameFromBaseUrl(baseUrl);
      }

      const existing = await profileService.getProfile(profileName);
      if (existing) {
        await profileService.confirmInitProfile(profileName, existing);
      }

      const keyPair = await profileService.generateKeyPair(profileName);

      const initResolve = {
        publicKey: keyPair.publicKey,
        keyId: keyPair.kid,
      };

      if (agentId.indexOf('usr') !== 0) {
        agentService = await AgentService.create(input, false);
      }

      const agent = await agentService.resolveInit(baseUrl, accountId, agentId, token, initResolve);

      const newProfile = {
        baseUrl,
        account: accountId,
        subscription: subscription === '' ? undefined : subscription || subscriptionId,
        boundary: boundaryId,
        function: functionId,
        agent: agentId,
        issuer: issuerId,
        subject: subject,
      };

      await profileService.initProfile(profileName, newProfile, keyPair);

      const defaultProfileName = await profileService.getDefaultProfileName();
      if (!defaultProfileName) {
        await profileService.setDefaultProfileName(profileName);
      }

      await agentService.initSuccess(profileName, agent);
    }
  }
}
